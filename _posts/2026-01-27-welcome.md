---
layout: post
title: "Welcome: This is My First Blog"
date: 2026-01-27
summary: "I finished a research paper on P2996 and UHT. But the work isn't over. I became very interested in static reflection and have ideas to explore. This blog documents that journey. Read the paper if you're interested."
tags: [C++26, P2996, reflection, research, programming languages]
---

This is my first blog post. I'm excited.

I wrote a research paper comparing P2996 (C++26 static reflection) with Unreal Engine's UHT reflection system. The paper focused on compile-time introspection as a language feature. But finishing it didn't feel like an ending. It felt like a starting point.

I became very interested in this topic. There's more to explore, and I have ideas how I want to expand this work. I want to document my findings and be transparent about what I learn along the way.

## What the research found

P2996R13 was accepted into C++26. It introduces compile-time introspection. Unlike Unreal's runtime reflection, P2996 resolves member and metadata information during compilation, not at runtime.

I compared four core capabilities: member lookup, serialization, property modification, and type information access. Here's what stood out:

**Syntax and macros:** UHT uses `UPROPERTY` and `UFUNCTION` macros on every member. You need boilerplate. P2996 uses generic operators like `nonstatic_data_members_of()` and splicing. No macro markup required.

**Error handling:** This is where the gap widens. P2996 catches errors at compile time with precise diagnostics. UHT defers error checking to runtime. When you get 2 annotations you didn't expect, UHT fails at runtime. P2996 can throw a compile error with a descriptive message about what went wrong.

**Feature limitations:** Some things are straightforward in P2996 but impossible in UHT. Examples shown are template reflection, reflective function invocation. These hit hard constraints in macro-based systems.

Full paper: <https://download.liamcremers.com/GW2526_Cremers_Liam_EN_Paper.pdf>

## The proof-of-concept projects

I built two demos. The baseline project exercises the basics: member iteration, JSON serialization, dynamic property access. Nothing fancy, just the fundamentals. You'd expect both P2996 and UHT to handle these similarly. They do.

The expanded project targets the features where differences actually appear. Custom annotations that enforce constraints at compile time. Reflective function calls using splicing operators. Template reflection. These show what static introspection enables that runtime systems struggle with.

Both include a pre-built P2996 toolchain (7.3GB, saves hours of compilation) and run on Linux/WSL.

- Baseline: <https://github.com/liamcremers/ReflectionProject>
- Expanded: <https://github.com/liamcremers/ReflectionProject_Expanded>

Quick run:

```bash
git clone https://github.com/liamcremers/ReflectionProject.git
cd ReflectionProject
./setup.sh
./build/Reflection
./watch.sh
```

```bash
git clone https://github.com/liamcremers/ReflectionProject_Expanded.git
cd ReflectionProject_Expanded
bash setup.sh
./build/Reflection
```

## What's next on this blog

The paper was narrow. One language, two systems, specific use cases. But reflection exists everywhere. C# has runtime reflection. Rust has procedural macros. Java has reflection APIs. Python has introspection. How do they compare? Where is P2996 better? Where does it fall short?

I'll explore:

- How P2996 compares to reflection in C#, Java, Rust, Python
- Practical patterns: serialization, editor tooling, metaprogramming
- What static reflection can do that runtime reflection can't, and vice versa
- Limitations we hit today, possibilities as the feature matures

Each post digs into a specific aspect with code examples. Subscribe via RSS if you want to follow along. Read the paper first if you want context.

Glad to have you here!
